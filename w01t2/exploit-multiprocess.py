from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from config import KEY_BYTE_CNT
import multiprocessing as mp

KEY_MAX = 256 ** KEY_BYTE_CNT

file_in = open("secret_big_case.bin", "rb")
tag, nonce, ciphertext = [ file_in.read(x) for x in (16, 16, -1) ]
file_in.close()


def try_once(key):
    try:
        cipher = AES.new(key.to_bytes(KEY_BYTE_CNT, byteorder="big").zfill(16), AES.MODE_GCM, nonce=nonce)
        data = cipher.decrypt_and_verify(ciphertext, tag)
    except ValueError:
        # decrypt failed, go to next round
        return False
    print("Password found! The source data is:")
    print(data.decode())
    return True

def try_seq(keys):
    for key in keys:
        res = try_once(key)
        if res:
            return True
    return False

def get_ranges(num_splits=64):
    
    split_size = KEY_MAX // num_splits  # 每份的大小
    remainder = KEY_MAX % num_splits  # 余数，用于处理不均匀分割的情况

    ranges = []
    start = 0

    for i in range(num_splits):
        end = start + split_size
        if i < remainder:  # 处理余数，使得前面的分割多分配一个元素
            end += 1
        ranges.append(range(start, end))
        start = end
    
    return ranges

if __name__ == "__main__":
    pool = mp.Pool(processes=64)
    ranges = get_ranges(num_splits=64)
    def callback(result):
        if result:
            pool.terminate()
    for r in ranges:
        pool.apply_async(try_seq, args=(r,), callback=callback)
    pool.close()
    pool.join()
