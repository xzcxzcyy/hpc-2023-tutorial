from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from config import KEY_BYTE_CNT
from mpi4py import MPI

KEY_MAX = 256 ** KEY_BYTE_CNT

file_in = open("secret_big_case.bin", "rb")
tag, nonce, ciphertext = [ file_in.read(x) for x in (16, 16, -1) ]
file_in.close()


def try_once(key):
    try:
        cipher = AES.new(key.to_bytes(KEY_BYTE_CNT, byteorder="big").zfill(16), AES.MODE_GCM, nonce=nonce)
        data = cipher.decrypt_and_verify(ciphertext, tag)
    except ValueError:
        # decrypt failed, go to next round
        return False
    print("Password found! The source data is:")
    print(data.decode())
    return True

def try_seq(keys):
    for key in keys:
        res = try_once(key)
        if res:
            return True
    return False

def get_ranges(num_splits=64):
    
    split_size = KEY_MAX // num_splits  # 每份的大小
    remainder = KEY_MAX % num_splits  # 余数，用于处理不均匀分割的情况

    ranges = []
    start = 0

    for i in range(num_splits):
        end = start + split_size
        if i < remainder:  # 处理余数，使得前面的分割多分配一个元素
            end += 1
        ranges.append(range(start, end))
        start = end
    
    return ranges

# 初始化MPI通信器
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

# 获取任务分割范围
ranges = get_ranges(num_splits=size)

# 将每个进程的范围分发到所有进程
ranges = comm.scatter(ranges, root=0)

# 并行执行任务
result = try_seq(ranges)

# 收集任务结果
results = comm.gather(result, root=0)

# 在根进程中判断是否有密码找到
if rank == 0:
    if any(results):
        print("Password found!")
    else:
        print("Password not found!")

# 结束MPI通信
MPI.Finalize()
